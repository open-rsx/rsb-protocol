package rsb.protocol;

option java_outer_classname = "Protocol";

// user-provided additional timing information
message UserTime {
    // The key is a string consisting of ASCII characters that
    // determines the meaning of the timestamp.
    required bytes      key       = 1;

    // A timestamp in microseconds.
    required uint64     timestamp = 2;
}

// additional-user-provided key-value-style meta data
message UserInfo {
    required bytes key = 1;
    required bytes value = 2;
}

message MetaData {
    // A time stamp that is automatically filled with the time the
    // event instance was created by the language binding. This should
    // usually reflect the time at which the notified condition most
    // likely occurred in the sender. If event instances are reused,
    // it has to be reset manually by the client.
    required int64      create_time             = 2;

    // The time at which the generated notification for an event was
    // sent on the bus (after serialization).
    required int64      send_time               = 3;

    // The time at which an event is received by listener in its
    // encoded form.
    optional int64      receive_time            = 4;

    // The time at which an event was decoded and will be dispatched
    // to the client as soon as possible (set directly before passing
    // it to the client handler).
    optional int64      deliver_time            = 5;

    // A set of key-value user-defined time-stamps.
    repeated UserTime   user_times              = 6;

    // A set of key-value user-defined options with string keys and values
    repeated UserInfo   user_infos              = 7;
}

message Notification {

    optional bytes      version                 = 1 [default = "1.0"];

    // The sequence number of the encoded event. This sequence number
    // is unique "within" the participant that sent the event.
    //
    // When combined with sender_id, uniquely identifies the encoded
    // event.
    required uint32     sequence_number         = 2;

    // ID (a UUID) of the sending participant as byte array. For this
    // encoding, the encoded UUID is 16 bytes long.
    //
    // When combined with sequence_number, uniquely identifies the
    // encoded event.
    required bytes      sender_id               = 3;

    // The scope under which the encoded event was sent
    optional bytes scope = 6;
    // The encoding format of the user data contained in the event
    optional bytes wire_schema = 7;
    // The contained user data
    optional bytes data = 9;

    // meta-data storage
    optional MetaData meta_data = 15;

    // The number of notifications an event was split into because the message
    // size would have been to big for monolithic sending. 1 indicates a
    // monolithic (self-contained) notification.
    optional uint32 num_data_parts = 11 [default = 1];
    // The index of the current part of a split message. Counting starts with 0
    optional uint32 data_part = 12 [default = 0];
    // a method type that is associated with this notification
    optional bytes method = 14 [default = ""];

}
