/* ============================================================
 *
 * This file is part of the RSB project.
 *
 * Copyright (C) 2011 The RSB developers.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General
 * Public License as published by the Free Software Foundation;
 * either version 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * ============================================================ */

package rsb.protocol;

option java_outer_classname = "Protocol";

// Additional user-provided timing information.
message UserTime {
    // The key is a string consisting of ASCII characters that
    // determines the meaning of the timestamp.
    required bytes      key                     = 1;

    // A timestamp in microseconds.
    required uint64     timestamp               = 2;
}

// Additional user-provided key-value-style meta data.
message UserInfo {
    required bytes      key                     = 1;
    required bytes      value                   = 2;
}

message MetaData {
    // A time stamp that is automatically filled with the time the
    // event instance was created by the language binding. This should
    // usually reflect the time at which the notified condition most
    // likely occurred in the sender. If event instances are reused,
    // it has to be reset manually by the client.
    required int64      create_time             = 2;

    // The time at which the generated notification for an event was
    // sent on the bus (after serialization).
    required int64      send_time               = 3;

    // The time at which an event is received by listener in its
    // encoded form.
    optional int64      receive_time            = 4;

    // The time at which an event was decoded and will be dispatched
    // to the client as soon as possible (set directly before passing
    // it to the client handler).
    optional int64      deliver_time            = 5;

    // A set of key-value user-defined time-stamps.
    repeated UserTime   user_times              = 6;

    // A set of key-value user-defined options with string keys and values
    repeated UserInfo   user_infos              = 7;
}

// The Notification message is the wire format and serialization
// mechanism used by the RSB Spread transport: Notification messages
// contain event routing information, event payloads and optional
// event meta-data such as timestamps.
//
// See https://code.cor-lab.org/projects/rsb/wiki/Events for more
// information regarding events and
// https://code.cor-lab.org/projects/rsb/wiki/SpreadProtocol for some
// aspects of the event <-> notification transformation.
message Notification {
    // Identity, transportation and routing information fields

    // The sequence number of the encoded event. This sequence number
    // is unique "within" the participant that sent the event.
    //
    // When combined with sender_id, uniquely identifies the encoded
    // event.
    //
    // The field number of this required field is generated based on
    // the current wire format version number to ensure runtime errors
    // for incompatible wire format versions.
    required uint32     sequence_number         = @WIRE_FORMAT_VERSION_FIELD_NUMBER@;

    // ID (a UUID) of the sending participant as byte array. For this
    // encoding, the encoded UUID is 16 bytes long.
    //
    // When combined with sequence_number, uniquely identifies the
    // encoded event.
    required bytes      sender_id               = 3;

    // The scope under which the encoded event was sent
    optional bytes      scope                   = 6;

    // a method type that is associated with this notification
    optional bytes      method                  = 14 [default = ""];


    // Data fields

    // The encoding format of the user data contained in the event
    optional bytes      wire_schema             = 7;

    // The contained user data
    optional bytes      data                    = 9;

    // The number of notifications an event was split into because the
    // message size would have been to big for monolithic sending. 1
    // indicates a monolithic (self-contained) notification.
    optional uint32     num_data_parts          = 11 [default = 1];

    // The index of the current part of a split message. Counting starts with 0
    optional uint32     data_part               = 12 [default = 0];


    // Meta-data fields

    // meta-data storage
    optional MetaData   meta_data               = 15;
}
